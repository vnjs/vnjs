
// Defines system constants Canvas Element constructors,


const TextTrail = {%
  function (args, context) {
    return context.system.TextTrail(args, context);
  }
%}

const LinearGradient = {%
  function (args, context) {
    return context.system.LinearGradient(args, context);
  }
%}

const RadialGradient = {%
  function (args, context) {
    return context.system.RadialGradient(args, context);
  }
%}

const Group = {%
  function (args, context) {
    return context.system.Group(args, context);
  }
%}



// Rectangle CanvasElement,
const vnjs.object.Rectangle = {%
  function (args, context) {

    // Create the canvas element object,
    var rectangle_ce = context.createDrawCanvasElement( args );

    // The draw function for this element,
    rectangle_ce.setDrawFunction( function(ctx2d, vns) {

      // The canvas element,
      var el = rectangle_ce.el;

      var roundedRect = context.lib.graphics.roundedRect;
      roundedRect(ctx2d, -(el.width / 2), -(el.height / 2), el.width, el.height, el.corner_radius );

      var type_fill_style = typeof el.fill_style;
      if (type_fill_style !== 'undefined') {
        if (type_fill_style === 'string') {
          ctx2d.fillStyle = el.fill_style;
        }
        else {
          // This must be an object of type LinearGradient or RadialGradient,
          // Check object type?
          ctx2d.fillStyle = el.fill_style.val;
        }
        ctx2d.fill();
      }
      if (el.stroke_style !== void 0) {
        ctx2d.strokeStyle = el.stroke_style;
        if (el.line_width !== void 0) {
          ctx2d.lineWidth = el.line_width;
        }
        else {
          ctx2d.lineWidth = 1;
        }
        ctx2d.stroke();
      }

    });

    return rectangle_ce;

  }
%}



// A CanvasElement object that draws a single line of text centered on the canvas element's
// location.
const vnjs.object.TextArt = {%
  function (args, context) {
    
    // Defaults,
    var config = {
      trail_width:          1280,
      trail_height:         100,
      pixels_between_words: 8,
      text_halign:          "center"
    };
    for (prop in args) {
      config[prop] = args[prop];
    }
    var formatter = context.lib.TextFormatter(config);

    var cur_text;
    var measured_text;

    // Create the canvas element object,
    var text_art = context.createDrawCanvasElement( config );
    
    // The draw function for this element,
    text_art.setDrawFunction( function(ctx2d, vns) {

      // Get the text content,
      var text_to_draw = text_art.el.text;
      if (cur_text !== text_to_draw) {
        // Do we need to measure it?
        // If the text changed since the last call it is re-measured here,
        cur_text = text_to_draw;
        measured_text = formatter.measureAndLayout(cur_text);
      }

      // Position and draw each word,
      var dx = -(text_art.el.trail_width / 2);
      var words_ar = measured_text.words_ar;
      for (var i = 0; i < words_ar.length; ++i) {
        var w = words_ar[i];
        ctx2d.font = w.word.style.fontSizeAndFamily;
        ctx2d.fillStyle = w.word.style.fontColor;
        ctx2d.fillText(w.word.text, dx + w.x, 0);
      }

    });

    return text_art;

  }
%}


// Aliases,
const TextArt = vnjs.object.TextArt;
const Rectangle = vnjs.object.Rectangle;




// Defines system constants Canvas Element constructors,


const LinearGradient = {%
  function (args, context) {
    return context.system.LinearGradient(args, context);
  }
%}

const RadialGradient = {%
  function (args, context) {
    return context.system.RadialGradient(args, context);
  }
%}

const Group = {%
  function (args, context) {
    return context.system.Group(args, context);
  }
%}


// A TextTrail object,
const TextTrail = {%

  // Anon-self invoking function to allow for constants,
  (function() {

    var DEFAULT_TTRAIL_CONFIG = {
      font_family: 'sans-serif',
      font_size: '25px',
      font_color: '#ffffff',
      pixels_between_words: 7,
      line_height: 30
    };

    return function (args, context) {
      var mergeConfig = context.lib.utils.mergeConfig;
      var setElementStyle = context.lib.setElementStyle;
      var vn_screen = context.getVNScreen();
      
      var ttconfig = {};
      if (args.width !== void 0) ttconfig.buffer_width = args.width;
      if (args.height !== void 0) ttconfig.buffer_height = args.height;

      ttconfig = mergeConfig(ttconfig, args);
      ttconfig = mergeConfig(ttconfig, DEFAULT_TTRAIL_CONFIG);
      
      var text_trail_ce = context.lib.TextTrail(vn_screen, ttconfig);
      vn_screen.addCanvasElement(text_trail_ce);
      
      var out = {
        args: args,
        el: text_trail_ce
      };

      setElementStyle(out, args, { buffer_width:-1, buffer_height:-1 } );
      return out;
    }

  })()

%}



// Rectangle CanvasElement,
const vnjs.object.Rectangle = {%
  function (args, context) {

    // Create the canvas element object,
    var rectangle_ce = context.createDrawCanvasElement( args );

    // The draw function for this element,
    rectangle_ce.setDrawFunction( function(ctx2d, vns) {

      // The current styling of the element,
      var cstyle = rectangle_ce.getStyles();

      var roundedRect = context.lib.graphics.roundedRect;
      roundedRect(ctx2d, -(cstyle.width / 2), -(cstyle.height / 2), cstyle.width, cstyle.height, cstyle.corner_radius );

      var type_fill_style = typeof cstyle.fill_style;
      if (type_fill_style !== 'undefined') {
        if (type_fill_style === 'string') {
          ctx2d.fillStyle = cstyle.fill_style;
        }
        else {
          // This must be an object of type LinearGradient or RadialGradient,
          // Check object type?
          ctx2d.fillStyle = cstyle.fill_style.val;
        }
        ctx2d.fill();
      }
      if (cstyle.stroke_style !== void 0) {
        ctx2d.strokeStyle = cstyle.stroke_style;
        if (cstyle.line_width !== void 0) {
          ctx2d.lineWidth = cstyle.line_width;
        }
        else {
          ctx2d.lineWidth = 1;
        }
        ctx2d.stroke();
      }

    });

    return rectangle_ce;

  }
%}



// A CanvasElement object that draws a single line of text centered on the canvas element's
// location.
const vnjs.object.TextArt = {%
  function (args, context) {
    
    // Defaults,
    var config = {
      trail_width:          1280,
      trail_height:         100,
      pixels_between_words: 8,
      text_halign:          "center"
    };
    for (prop in args) {
      config[prop] = args[prop];
    }
    var formatter = context.lib.TextFormatter(config);

    var cur_text;
    var measured_text;

    // Create the canvas element object,
    var text_art = context.createDrawCanvasElement( config );
    
    // The draw function for this element,
    text_art.setDrawFunction( function(ctx2d, vns) {

      var cstyle = text_art.getStyles();
      
      // Get the text content,
      var text_to_draw = cstyle.text;
      if (cur_text !== text_to_draw) {
        // Do we need to measure it?
        // If the text changed since the last call it is re-measured here,
        cur_text = text_to_draw;
        measured_text = formatter.measureAndLayout(cur_text);
      }

      // Position and draw each word,
      var dx = -(cstyle.trail_width / 2);
      var words_ar = measured_text.words_ar;
      for (var i = 0; i < words_ar.length; ++i) {
        var w = words_ar[i];
        ctx2d.font = w.word.style.fontSizeAndFamily;
        ctx2d.fillStyle = w.word.style.fontColor;
        ctx2d.fillText(w.word.text, dx + w.x, 0);
      }

    });

    return text_art;

  }
%}


// Aliases,
const TextArt = vnjs.object.TextArt;
const Rectangle = vnjs.object.Rectangle;


